# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Account {
  availableBalance: Float
  balance: Float
  createdAt: DateTime!
  currency: EnumAccountCurrency
  description: String
  id: String!
  name: String
  status: EnumAccountStatus
  transactions(
    orderBy: [TransactionOrderByInput!]
    skip: Float
    take: Float
    where: TransactionWhereInput
  ): [Transaction!]!
  updatedAt: DateTime!
  user: User
}

input AccountCreateInput {
  availableBalance: Float
  balance: Float
  currency: EnumAccountCurrency
  description: String
  name: String
  status: EnumAccountStatus
  transactions: TransactionCreateNestedManyWithoutAccountsInput
  user: UserWhereUniqueInput
}

input AccountCreateNestedManyWithoutTransactionsInput {
  connect: [AccountWhereUniqueInput!]
}

input AccountCreateNestedManyWithoutUsersInput {
  connect: [AccountWhereUniqueInput!]
}

input AccountListRelationFilter {
  every: AccountWhereInput
  none: AccountWhereInput
  some: AccountWhereInput
}

input AccountOrderByInput {
  availableBalance: SortOrder
  balance: SortOrder
  createdAt: SortOrder
  currency: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
  status: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input AccountUpdateInput {
  availableBalance: Float
  balance: Float
  currency: EnumAccountCurrency
  description: String
  name: String
  status: EnumAccountStatus
  transactions: TransactionUpdateManyWithoutAccountsInput
  user: UserWhereUniqueInput
}

input AccountUpdateManyWithoutTransactionsInput {
  connect: [AccountWhereUniqueInput!]
  disconnect: [AccountWhereUniqueInput!]
  set: [AccountWhereUniqueInput!]
}

input AccountUpdateManyWithoutUsersInput {
  connect: [AccountWhereUniqueInput!]
  disconnect: [AccountWhereUniqueInput!]
  set: [AccountWhereUniqueInput!]
}

input AccountWhereInput {
  availableBalance: FloatNullableFilter
  balance: FloatNullableFilter
  currency: EnumAccountCurrency
  description: StringNullableFilter
  id: StringFilter
  name: StringNullableFilter
  status: EnumAccountStatus
  transactions: TransactionListRelationFilter
  user: UserWhereUniqueInput
}

input AccountWhereUniqueInput {
  id: String!
}

type Address {
  address_1: String
  address_2: String
  city: String
  createdAt: DateTime!
  id: String!
  state: String
  updatedAt: DateTime!
  zip: Float
}

input AddressCreateInput {
  address_1: String
  address_2: String
  city: String
  state: String
  zip: Float
}

input AddressOrderByInput {
  address_1: SortOrder
  address_2: SortOrder
  city: SortOrder
  createdAt: SortOrder
  id: SortOrder
  state: SortOrder
  updatedAt: SortOrder
  zip: SortOrder
}

input AddressUpdateInput {
  address_1: String
  address_2: String
  city: String
  state: String
  zip: Float
}

input AddressWhereInput {
  address_1: StringNullableFilter
  address_2: StringNullableFilter
  city: StringNullableFilter
  id: StringFilter
  state: StringNullableFilter
  zip: IntNullableFilter
}

input AddressWhereUniqueInput {
  id: String!
}

input Credentials {
  password: String!
  username: String!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type Document {
  createdAt: DateTime!
  documentType: EnumDocumentDocumentType
  id: String!
  status: EnumDocumentStatus
  updatedAt: DateTime!
  url: String!
  user: User
}

input DocumentCreateInput {
  documentType: EnumDocumentDocumentType!
  status: EnumDocumentStatus
  url: String!
  user: UserWhereUniqueInput
}

input DocumentCreateNestedManyWithoutUsersInput {
  connect: [DocumentWhereUniqueInput!]
}

input DocumentListRelationFilter {
  every: DocumentWhereInput
  none: DocumentWhereInput
  some: DocumentWhereInput
}

input DocumentOrderByInput {
  createdAt: SortOrder
  documentType: SortOrder
  id: SortOrder
  status: SortOrder
  updatedAt: SortOrder
  url: SortOrder
  userId: SortOrder
}

input DocumentUpdateInput {
  documentType: EnumDocumentDocumentType
  status: EnumDocumentStatus
  url: String
  user: UserWhereUniqueInput
}

input DocumentUpdateManyWithoutUsersInput {
  connect: [DocumentWhereUniqueInput!]
  disconnect: [DocumentWhereUniqueInput!]
  set: [DocumentWhereUniqueInput!]
}

input DocumentWhereInput {
  documentType: EnumDocumentDocumentType
  id: StringFilter
  status: EnumDocumentStatus
  url: StringFilter
  user: UserWhereUniqueInput
}

input DocumentWhereUniqueInput {
  id: String!
}

enum EnumAccountCurrency {
  Celo
  Eur
  Usd
  Xof
}

enum EnumAccountStatus {
  Approved
  Blocked
  Pending
}

enum EnumDocumentDocumentType {
  Driverlicence
  GovernmentId
  Passport
}

enum EnumDocumentStatus {
  Approved
  Rejected
}

enum EnumTransactionStatus {
  Failed
  Pending
  Successful
}

enum EnumTransactionTransactionSubtype {
  Bank
  Cash
  Crypto
  Momo
}

enum EnumTransactionTransactionType {
  Credit
  Debit
}

enum EnumUserStatus {
  Approved
  Pending
  Rejected
}

input FloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: Float
  notIn: [Float!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON
  @specifiedBy(
    url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf"
  )

type MetaQueryPayload {
  count: Float!
}

type Mutation {
  createAccount(data: AccountCreateInput!): Account!
  createAddress(data: AddressCreateInput!): Address!
  createDocument(data: DocumentCreateInput!): Document!
  createTransaction(data: TransactionCreateInput!): Transaction!
  createUser(data: UserCreateInput!): User!
  deleteAccount(where: AccountWhereUniqueInput!): Account!
  deleteAddress(where: AddressWhereUniqueInput!): Address!
  deleteDocument(where: DocumentWhereUniqueInput!): Document!
  deleteTransaction(where: TransactionWhereUniqueInput!): Transaction!
  deleteUser(where: UserWhereUniqueInput!): User!
  login(credentials: Credentials!): UserInfo!
  updateAccount(
    data: AccountUpdateInput!
    where: AccountWhereUniqueInput!
  ): Account!
  updateAddress(
    data: AddressUpdateInput!
    where: AddressWhereUniqueInput!
  ): Address!
  updateDocument(
    data: DocumentUpdateInput!
    where: DocumentWhereUniqueInput!
  ): Document!
  updateTransaction(
    data: TransactionUpdateInput!
    where: TransactionWhereUniqueInput!
  ): Transaction!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

type Query {
  _accountsMeta(
    orderBy: [AccountOrderByInput!]
    skip: Float
    take: Float
    where: AccountWhereInput
  ): MetaQueryPayload!
  _addressesMeta(
    orderBy: [AddressOrderByInput!]
    skip: Float
    take: Float
    where: AddressWhereInput
  ): MetaQueryPayload!
  _documentsMeta(
    orderBy: [DocumentOrderByInput!]
    skip: Float
    take: Float
    where: DocumentWhereInput
  ): MetaQueryPayload!
  _transactionsMeta(
    orderBy: [TransactionOrderByInput!]
    skip: Float
    take: Float
    where: TransactionWhereInput
  ): MetaQueryPayload!
  _usersMeta(
    orderBy: [UserOrderByInput!]
    skip: Float
    take: Float
    where: UserWhereInput
  ): MetaQueryPayload!
  account(where: AccountWhereUniqueInput!): Account
  accounts(
    orderBy: [AccountOrderByInput!]
    skip: Float
    take: Float
    where: AccountWhereInput
  ): [Account!]!
  address(where: AddressWhereUniqueInput!): Address
  addresses(
    orderBy: [AddressOrderByInput!]
    skip: Float
    take: Float
    where: AddressWhereInput
  ): [Address!]!
  document(where: DocumentWhereUniqueInput!): Document
  documents(
    orderBy: [DocumentOrderByInput!]
    skip: Float
    take: Float
    where: DocumentWhereInput
  ): [Document!]!
  transaction(where: TransactionWhereUniqueInput!): Transaction
  transactions(
    orderBy: [TransactionOrderByInput!]
    skip: Float
    take: Float
    where: TransactionWhereInput
  ): [Transaction!]!
  user(where: UserWhereUniqueInput!): User
  userInfo: UserInfo!
  users(
    orderBy: [UserOrderByInput!]
    skip: Float
    take: Float
    where: UserWhereInput
  ): [User!]!
}

enum QueryMode {
  Default
  Insensitive
}

enum SortOrder {
  Asc
  Desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: String
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: String
  notIn: [String!]
  startsWith: String
}

type Transaction {
  accounts(
    orderBy: [AccountOrderByInput!]
    skip: Float
    take: Float
    where: AccountWhereInput
  ): [Account!]!
  amount: Float!
  createdAt: DateTime!
  fee: Float
  id: String!
  status: EnumTransactionStatus
  transactionSubtype: EnumTransactionTransactionSubtype
  transactionType: EnumTransactionTransactionType
  updatedAt: DateTime!
}

input TransactionCreateInput {
  accounts: AccountCreateNestedManyWithoutTransactionsInput
  amount: Float!
  fee: Float
  status: EnumTransactionStatus!
  transactionSubtype: EnumTransactionTransactionSubtype
  transactionType: EnumTransactionTransactionType!
}

input TransactionCreateNestedManyWithoutAccountsInput {
  connect: [TransactionWhereUniqueInput!]
}

input TransactionListRelationFilter {
  every: TransactionWhereInput
  none: TransactionWhereInput
  some: TransactionWhereInput
}

input TransactionOrderByInput {
  amount: SortOrder
  createdAt: SortOrder
  fee: SortOrder
  id: SortOrder
  status: SortOrder
  transactionSubtype: SortOrder
  transactionType: SortOrder
  updatedAt: SortOrder
}

input TransactionUpdateInput {
  accounts: AccountUpdateManyWithoutTransactionsInput
  amount: Float
  fee: Float
  status: EnumTransactionStatus
  transactionSubtype: EnumTransactionTransactionSubtype
  transactionType: EnumTransactionTransactionType
}

input TransactionUpdateManyWithoutAccountsInput {
  connect: [TransactionWhereUniqueInput!]
  disconnect: [TransactionWhereUniqueInput!]
  set: [TransactionWhereUniqueInput!]
}

input TransactionWhereInput {
  accounts: AccountListRelationFilter
  id: StringFilter
  transactionSubtype: EnumTransactionTransactionSubtype
  transactionType: EnumTransactionTransactionType
}

input TransactionWhereUniqueInput {
  id: String!
}

type User {
  accounts(
    orderBy: [AccountOrderByInput!]
    skip: Float
    take: Float
    where: AccountWhereInput
  ): [Account!]!
  address: JSON!
  businessName: String
  createdAt: DateTime!
  documents(
    orderBy: [DocumentOrderByInput!]
    skip: Float
    take: Float
    where: DocumentWhereInput
  ): [Document!]!
  email: String!
  firstName: String
  id: String!
  lastName: String
  phoe: String!
  roles: JSON!
  status: EnumUserStatus
  updatedAt: DateTime!
  username: String!
}

input UserCreateInput {
  accounts: AccountCreateNestedManyWithoutUsersInput
  address: JSON!
  businessName: String
  documents: DocumentCreateNestedManyWithoutUsersInput
  email: String!
  firstName: String
  lastName: String
  password: String!
  phoe: String!
  roles: JSON!
  status: EnumUserStatus
  username: String!
}

type UserInfo {
  accessToken: String
  id: String!
  roles: [String!]!
  username: String!
}

input UserOrderByInput {
  address: SortOrder
  businessName: SortOrder
  createdAt: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  phoe: SortOrder
  roles: SortOrder
  status: SortOrder
  updatedAt: SortOrder
  username: SortOrder
}

input UserUpdateInput {
  accounts: AccountUpdateManyWithoutUsersInput
  address: JSON
  businessName: String
  documents: DocumentUpdateManyWithoutUsersInput
  email: String
  firstName: String
  lastName: String
  password: String
  phoe: String
  roles: JSON
  status: EnumUserStatus
  username: String
}

input UserWhereInput {
  accounts: AccountListRelationFilter
  businessName: StringNullableFilter
  documents: DocumentListRelationFilter
  email: StringFilter
  firstName: StringNullableFilter
  id: StringFilter
  lastName: StringNullableFilter
  status: EnumUserStatus
  username: StringFilter
}

input UserWhereUniqueInput {
  id: String!
}
